// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	sync "sync"

	models "github.com/BrandonWade/enako/api/models"
	repositories "github.com/BrandonWade/enako/api/repositories"
)

type FakeExpenseRepository struct {
	CreateExpenseStub        func(int64, *models.UserExpense) (int64, error)
	createExpenseMutex       sync.RWMutex
	createExpenseArgsForCall []struct {
		arg1 int64
		arg2 *models.UserExpense
	}
	createExpenseReturns struct {
		result1 int64
		result2 error
	}
	createExpenseReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	DeleteExpenseStub        func(int64, int64) (int64, error)
	deleteExpenseMutex       sync.RWMutex
	deleteExpenseArgsForCall []struct {
		arg1 int64
		arg2 int64
	}
	deleteExpenseReturns struct {
		result1 int64
		result2 error
	}
	deleteExpenseReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	GetExpensesStub        func(int64) ([]models.UserExpense, error)
	getExpensesMutex       sync.RWMutex
	getExpensesArgsForCall []struct {
		arg1 int64
	}
	getExpensesReturns struct {
		result1 []models.UserExpense
		result2 error
	}
	getExpensesReturnsOnCall map[int]struct {
		result1 []models.UserExpense
		result2 error
	}
	UpdateExpenseStub        func(int64, int64, *models.UserExpense) (int64, error)
	updateExpenseMutex       sync.RWMutex
	updateExpenseArgsForCall []struct {
		arg1 int64
		arg2 int64
		arg3 *models.UserExpense
	}
	updateExpenseReturns struct {
		result1 int64
		result2 error
	}
	updateExpenseReturnsOnCall map[int]struct {
		result1 int64
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeExpenseRepository) CreateExpense(arg1 int64, arg2 *models.UserExpense) (int64, error) {
	fake.createExpenseMutex.Lock()
	ret, specificReturn := fake.createExpenseReturnsOnCall[len(fake.createExpenseArgsForCall)]
	fake.createExpenseArgsForCall = append(fake.createExpenseArgsForCall, struct {
		arg1 int64
		arg2 *models.UserExpense
	}{arg1, arg2})
	fake.recordInvocation("CreateExpense", []interface{}{arg1, arg2})
	fake.createExpenseMutex.Unlock()
	if fake.CreateExpenseStub != nil {
		return fake.CreateExpenseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createExpenseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExpenseRepository) CreateExpenseCallCount() int {
	fake.createExpenseMutex.RLock()
	defer fake.createExpenseMutex.RUnlock()
	return len(fake.createExpenseArgsForCall)
}

func (fake *FakeExpenseRepository) CreateExpenseCalls(stub func(int64, *models.UserExpense) (int64, error)) {
	fake.createExpenseMutex.Lock()
	defer fake.createExpenseMutex.Unlock()
	fake.CreateExpenseStub = stub
}

func (fake *FakeExpenseRepository) CreateExpenseArgsForCall(i int) (int64, *models.UserExpense) {
	fake.createExpenseMutex.RLock()
	defer fake.createExpenseMutex.RUnlock()
	argsForCall := fake.createExpenseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExpenseRepository) CreateExpenseReturns(result1 int64, result2 error) {
	fake.createExpenseMutex.Lock()
	defer fake.createExpenseMutex.Unlock()
	fake.CreateExpenseStub = nil
	fake.createExpenseReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) CreateExpenseReturnsOnCall(i int, result1 int64, result2 error) {
	fake.createExpenseMutex.Lock()
	defer fake.createExpenseMutex.Unlock()
	fake.CreateExpenseStub = nil
	if fake.createExpenseReturnsOnCall == nil {
		fake.createExpenseReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.createExpenseReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) DeleteExpense(arg1 int64, arg2 int64) (int64, error) {
	fake.deleteExpenseMutex.Lock()
	ret, specificReturn := fake.deleteExpenseReturnsOnCall[len(fake.deleteExpenseArgsForCall)]
	fake.deleteExpenseArgsForCall = append(fake.deleteExpenseArgsForCall, struct {
		arg1 int64
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("DeleteExpense", []interface{}{arg1, arg2})
	fake.deleteExpenseMutex.Unlock()
	if fake.DeleteExpenseStub != nil {
		return fake.DeleteExpenseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteExpenseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExpenseRepository) DeleteExpenseCallCount() int {
	fake.deleteExpenseMutex.RLock()
	defer fake.deleteExpenseMutex.RUnlock()
	return len(fake.deleteExpenseArgsForCall)
}

func (fake *FakeExpenseRepository) DeleteExpenseCalls(stub func(int64, int64) (int64, error)) {
	fake.deleteExpenseMutex.Lock()
	defer fake.deleteExpenseMutex.Unlock()
	fake.DeleteExpenseStub = stub
}

func (fake *FakeExpenseRepository) DeleteExpenseArgsForCall(i int) (int64, int64) {
	fake.deleteExpenseMutex.RLock()
	defer fake.deleteExpenseMutex.RUnlock()
	argsForCall := fake.deleteExpenseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeExpenseRepository) DeleteExpenseReturns(result1 int64, result2 error) {
	fake.deleteExpenseMutex.Lock()
	defer fake.deleteExpenseMutex.Unlock()
	fake.DeleteExpenseStub = nil
	fake.deleteExpenseReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) DeleteExpenseReturnsOnCall(i int, result1 int64, result2 error) {
	fake.deleteExpenseMutex.Lock()
	defer fake.deleteExpenseMutex.Unlock()
	fake.DeleteExpenseStub = nil
	if fake.deleteExpenseReturnsOnCall == nil {
		fake.deleteExpenseReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.deleteExpenseReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) GetExpenses(arg1 int64) ([]models.UserExpense, error) {
	fake.getExpensesMutex.Lock()
	ret, specificReturn := fake.getExpensesReturnsOnCall[len(fake.getExpensesArgsForCall)]
	fake.getExpensesArgsForCall = append(fake.getExpensesArgsForCall, struct {
		arg1 int64
	}{arg1})
	fake.recordInvocation("GetExpenses", []interface{}{arg1})
	fake.getExpensesMutex.Unlock()
	if fake.GetExpensesStub != nil {
		return fake.GetExpensesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getExpensesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExpenseRepository) GetExpensesCallCount() int {
	fake.getExpensesMutex.RLock()
	defer fake.getExpensesMutex.RUnlock()
	return len(fake.getExpensesArgsForCall)
}

func (fake *FakeExpenseRepository) GetExpensesCalls(stub func(int64) ([]models.UserExpense, error)) {
	fake.getExpensesMutex.Lock()
	defer fake.getExpensesMutex.Unlock()
	fake.GetExpensesStub = stub
}

func (fake *FakeExpenseRepository) GetExpensesArgsForCall(i int) int64 {
	fake.getExpensesMutex.RLock()
	defer fake.getExpensesMutex.RUnlock()
	argsForCall := fake.getExpensesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeExpenseRepository) GetExpensesReturns(result1 []models.UserExpense, result2 error) {
	fake.getExpensesMutex.Lock()
	defer fake.getExpensesMutex.Unlock()
	fake.GetExpensesStub = nil
	fake.getExpensesReturns = struct {
		result1 []models.UserExpense
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) GetExpensesReturnsOnCall(i int, result1 []models.UserExpense, result2 error) {
	fake.getExpensesMutex.Lock()
	defer fake.getExpensesMutex.Unlock()
	fake.GetExpensesStub = nil
	if fake.getExpensesReturnsOnCall == nil {
		fake.getExpensesReturnsOnCall = make(map[int]struct {
			result1 []models.UserExpense
			result2 error
		})
	}
	fake.getExpensesReturnsOnCall[i] = struct {
		result1 []models.UserExpense
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) UpdateExpense(arg1 int64, arg2 int64, arg3 *models.UserExpense) (int64, error) {
	fake.updateExpenseMutex.Lock()
	ret, specificReturn := fake.updateExpenseReturnsOnCall[len(fake.updateExpenseArgsForCall)]
	fake.updateExpenseArgsForCall = append(fake.updateExpenseArgsForCall, struct {
		arg1 int64
		arg2 int64
		arg3 *models.UserExpense
	}{arg1, arg2, arg3})
	fake.recordInvocation("UpdateExpense", []interface{}{arg1, arg2, arg3})
	fake.updateExpenseMutex.Unlock()
	if fake.UpdateExpenseStub != nil {
		return fake.UpdateExpenseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateExpenseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeExpenseRepository) UpdateExpenseCallCount() int {
	fake.updateExpenseMutex.RLock()
	defer fake.updateExpenseMutex.RUnlock()
	return len(fake.updateExpenseArgsForCall)
}

func (fake *FakeExpenseRepository) UpdateExpenseCalls(stub func(int64, int64, *models.UserExpense) (int64, error)) {
	fake.updateExpenseMutex.Lock()
	defer fake.updateExpenseMutex.Unlock()
	fake.UpdateExpenseStub = stub
}

func (fake *FakeExpenseRepository) UpdateExpenseArgsForCall(i int) (int64, int64, *models.UserExpense) {
	fake.updateExpenseMutex.RLock()
	defer fake.updateExpenseMutex.RUnlock()
	argsForCall := fake.updateExpenseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeExpenseRepository) UpdateExpenseReturns(result1 int64, result2 error) {
	fake.updateExpenseMutex.Lock()
	defer fake.updateExpenseMutex.Unlock()
	fake.UpdateExpenseStub = nil
	fake.updateExpenseReturns = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) UpdateExpenseReturnsOnCall(i int, result1 int64, result2 error) {
	fake.updateExpenseMutex.Lock()
	defer fake.updateExpenseMutex.Unlock()
	fake.UpdateExpenseStub = nil
	if fake.updateExpenseReturnsOnCall == nil {
		fake.updateExpenseReturnsOnCall = make(map[int]struct {
			result1 int64
			result2 error
		})
	}
	fake.updateExpenseReturnsOnCall[i] = struct {
		result1 int64
		result2 error
	}{result1, result2}
}

func (fake *FakeExpenseRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createExpenseMutex.RLock()
	defer fake.createExpenseMutex.RUnlock()
	fake.deleteExpenseMutex.RLock()
	defer fake.deleteExpenseMutex.RUnlock()
	fake.getExpensesMutex.RLock()
	defer fake.getExpensesMutex.RUnlock()
	fake.updateExpenseMutex.RLock()
	defer fake.updateExpenseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeExpenseRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ repositories.ExpenseRepository = new(FakeExpenseRepository)
